<!DOCTYPE html>
<html lang="en">
<head>
    <script src="trackPlayerInputs.js" defer></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris Game</title>



    <style>
        body { text-align: center; margin: 0; padding: 0; }
        canvas { border: 1px solid #000; }
        #background { position: absolute; top: 0; left: 0; }
        #start-button {background-color: #04AA6D; margin-top: 20px; font-size: 20px;}
        #next-button{position:center; bottom:60px;}
        #timer { font-size: 24px; }
        #score, #lines {text-align: center; font-size: 18px; }
        #end-message { display: none; font-size: 24px; color: red; }
    </style>

<style>
    #countdown {
      font-size: 18px;
      font-weight: bold;
      display: none;  /* Hide the countdown div initially */
      margin: 0;
     position: absolute;
     bottom: 3%;  /* Position at the bottom of the page */
     left: 50%;  /* Center it horizontally */
     transform: translateX(-50%);  /* Adjust for exact horizontal centering */
    }

    #time-elapsed {
      position: absolute;
      top: 20px;
      right: 20px;
      font-size: 18px;
      background-color: rgba(0, 0, 0, 0.5);
      color: white;
      padding: 5px 10px;
      border-radius: 5px;
    }
    
  </style>


    <link rel="stylesheet" href="index.css"> 
</head>

<body>

<!--<h1 style="font-size:2em"> Round  Game</h1>-->
<h1><div id="round-display">Round 1 Game </div></h1>


<!--<div id="time-elapsed">Elapsed Time: 0s</div>-->
<div id="countdown">Next page will load in: 5 seconds</div>

<div style="width:100%;">
    <div style="width:50%; height: 600px; float: left">
        <button id="start-button">Start Game</button>
        <div id="timer">01:00</div>
  
        <br>
        <br>
        <br>
        <br>
        <div id="score">Score: 0</div>
        <div id="lines">Lines: 0</div>
        <div id="end-message">Game Over!</div>

        <br>
        <br> 
      <b class="blue-text">Your Partner's Screen</b>
      <div class="videobox">
        <!--<video id="gameVideo" width="600" height="350" autoplay muted>
            <source src="resources/round1.mp4" type="video/mp4">
            
        </video>-->

        <video id="gameVideo" width="600" height="350" autoplay muted>
            <source id="videoSource" type="video/mp4">
            Your browser does not support the video tag.
        </video>

    </div>


      


    </div>
</div>

<br>
        
<b class="blue-text">Your Game Screen</b>
<div style="width: 50%; height: 600px; float: right">
    <canvas id="game-canvas" width="308" height="558"></canvas>
</div>




  <script>
       let countdown;
       let countdownValue = 5;
        let timeLeft = 60;
        let gameStarted = false;
        let score = 0;
        let lines = 0;
        let gameOver = false;
        let tetromino = null;
        const FIELD_WIDTH = 11;
        const FIELD_HEIGHT = 20;
        const FIELD = Array.from({ length: FIELD_HEIGHT }, () => Array(FIELD_WIDTH).fill(false));


        // Assuming loopCount is initialized globally or fetched from the URL
//let loopCount = parseInt(new URLSearchParams(window.location.search).get('loopCount')) || 1;  

//let loopCount = parseInt(new URLSearchParams(window.location.search).get('loopCount'));
//let loopCount = params.get('loopCount');
//console.log(loopCount);  // Should log '1' if it's present in the URL

let countdownInterval;



        // Log the current URL query string to check if the loopCount parameter exists
        console.log(window.location.search); // Should log: "?loopCount=1"

        // Extract the loopCount from the URL query string
        let loopCount = parseInt(new URLSearchParams(window.location.search).get('loopCount')) || 1;

        // Log the loopCount to verify it's correctly parsed
        console.log('Loop Count:', loopCount);


       
        
        function updateGame() {
   


    // Update the round display
    document.getElementById('round-display').textContent = `Round ${loopCount} Game`;
    document.getElementById('score-display').textContent = `Score: ${score}`;
    document.getElementById('lines-display').textContent = `Lines: ${lines}`;






    // Update the video based on loopCount
    //const videoSource = document.getElementById('gameVideo').querySelector('source');
//let videoSourceFile = '';

// Based on the loopCount, set the appropriate video source
//if (loopCount === 1) {
    //videoSourceFile = 'resources/round1.mp4';
//} else if (loopCount === 2) {
    //videoSourceFile = 'resources/round2.mp4';
//} else if (loopCount === 3) {
    //videoSourceFile = 'resources/round3.mp4';
//} else if (loopCount === 4) {
   // videoSourceFile = 'resources/round4.mp4';
//} else if (loopCount === 5) {
    //videoSourceFile = 'resources/round5.mp4';
//} else if (loopCount === 6) {
   // videoSourceFile = 'resources/round6.mp4';
//} else if (loopCount === 7) {
    //videoSourceFile = 'resources/round7.mp4';
//} else {
    //videoSourceFile = 'resources/round8.mp4';  // Default if there are more rounds
//}





// Update the video source dynamically
//videoSource.src = videoSourceFile;

// Reload the video to play the new one
//document.getElementById('gameVideo').load();







    // Reload the video element to apply the new source
   // const videoElement = document.getElementById('gameVideo');
   // videoElement.load();  // Reload the video element to apply the new video
   // videoElement.play();  // Start playing the new video

    // Ensure the video plays after updating
   // if (videoElement.paused) {
        //videoElement.play();
   // }









}




    // Get the loopCount from the URL
    //const loopCount = parseInt(new URLSearchParams(window.location.search).get('loopCount')) || 1;
   // console.log('Loop Count:', loopCount);  // For debugging

    // Determine the correct video source file based on loopCount
    let videoSourceFile = '';

    if (loopCount === 1) {
        videoSourceFile = 'resources/round1.mp4';
    } else if (loopCount === 2) {
        videoSourceFile = 'resources/round2.mp4';
    } else if (loopCount === 3) {
        videoSourceFile = 'resources/round3.mp4';
    } else if (loopCount === 4) {
        videoSourceFile = 'resources/round4.mp4';
    } else if (loopCount === 5) {
        videoSourceFile = 'resources/round5.mp4';
    } else if (loopCount === 6) {
        videoSourceFile = 'resources/round6.mp4';
    } else if (loopCount === 7) {
        videoSourceFile = 'resources/round7.mp4';
    } else {
        videoSourceFile = 'resources/round8.mp4';  // Default if there are more rounds
    }

    // Log to confirm the video source is set correctly
    console.log('Video Source File:', videoSourceFile);

    // Get the video source element
    const videoSource = document.getElementById('videoSource');
    
    // Update the video source dynamically
    videoSource.src = videoSourceFile;

    // Get the video element
    const videoElement = document.getElementById('gameVideo');
    
    // Reload and play the video
    videoElement.load();  // Reload the video element to apply the new video source
    videoElement.play();  // Start playing the new video

    // Ensure the video plays after updating
    if (videoElement.paused) {
        videoElement.play();
    }









        const canvas = document.getElementById("game-canvas");
        const ctx = canvas.getContext("2d");
        const startButton = document.getElementById("start-button");
        const timerDisplay = document.getElementById("timer");
        const scoreLbl = document.getElementById("score");
        const linesLbl = document.getElementById("lines");
        const endMessage = document.getElementById("end-message");
        //const timeElapsedElement = document.getElementById("time-elapsed");


// Function to start and track elapsed time across pages
function startTimer() {
  // Check if it's the first page load (determine this by the URL or a flag)
  //if (window.location.pathname === "/tetris.html") {
    // Always reset the timer to 0 when the first page is loaded
    //localStorage.setItem('elapsedTime', 0);
  //}

  // Retrieve the previous elapsed time from localStorage (defaults to 0 if not set)
  //let elapsedTime = parseInt(localStorage.getItem('elapsedTime')) || 0;

  // Find the element to update the time display
  //const timeElapsedElement = document.getElementById('time-elapsed');

  // Function to update the elapsed time and store it in localStorage
  //const updateElapsedTime = () => {
    //elapsedTime++;  // Increment elapsed time by 1 second
    //timeElapsedElement.textContent = `Elapsed Time: ${elapsedTime}s`;

    // Store the updated elapsed time in localStorage
    //localStorage.setItem('elapsedTime', elapsedTime);
  //};

  // Update elapsed time immediately when the page loads
  //updateElapsedTime();

  // Set an interval to update the elapsed time every second
  //setInterval(updateElapsedTime, 1000);
}

// Ensure the timer starts when the page is loaded
window.onload = function() {
  startTimer();
};

        // Start countdown for game timer
        function updateTimer() {
            timeLeft--;
            const minutes = Math.floor(timeLeft / 60);
            const seconds = timeLeft % 60;
            timerDisplay.textContent = `${minutes < 10 ? '0' + minutes : minutes}:${seconds < 10 ? '0' + seconds : seconds}`;

            if (timeLeft <= 0) {
                clearInterval(countdown);
                endGame();
            }
        }

        // Start the game
        function startGame() {
            gameStarted = true;
            startButton.disabled = true;
            startButton.innerText = "Game Started...";
            countdown = setInterval(updateTimer, 1000);
            reset();
            draw();
        }

        // End the game
        function endGame() {
            gameOver = true;
            endMessage.style.display = 'block';
            timerDisplay.style.display = 'none';
            scoreLbl.style.display = 'none';
            linesLbl.style.display = 'none';
        }

        // Reset the game state
        function reset() {
            FIELD.forEach((_, y) => FIELD[y] = Array(FIELD_WIDTH).fill(false));
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            score = 0;
            lines = 0;
            gameStarted = false;
            gameOver = false;
            scoreLbl.textContent = `Score: ${score}`;
            linesLbl.textContent = `Lines: ${lines}`;
        }

        // Game loop
        function draw() {
            if (gameOver) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // Game drawing logic goes here (like tetrominoes, field, etc.)

            setTimeout(draw, 500);  // Continue the game loop
        }

        // Set up event listener for the start button
        startButton.addEventListener('click', startGame);

        // Start elapsed timer on page load
        //window.onload = function() {
            //startTimer();  // Start elapsed time
            //if (!gameStarted) startGame();  // Start the game immediately on load
        //};
 


    // Tetromino class definition
    class Tetromino {
      
        //static COLORS = ["blue", "green", "yellow", "red", "orange", "light-blue", "purple"];
        static BLOCK_SIZE = 28;
        static DELAY = 400;
        static DELAY_INCREASED = 5;

        constructor(xs, ys, color) {
            this.x = xs;
            this.y = ys;
            this.color = color;
            this.length = xs.length;
        }

        // Draw the tetromino on the canvas
        draw() {
            for (let i = 0; i < this.length; i++) {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x[i] * Tetromino.BLOCK_SIZE, this.y[i] * Tetromino.BLOCK_SIZE, Tetromino.BLOCK_SIZE, Tetromino.BLOCK_SIZE);
            }
        }

        // Clear the tetromino's previous position
        clear() {
            for (let i = 0; i < this.length; i++) {
                ctx.clearRect(this.x[i] * Tetromino.BLOCK_SIZE, this.y[i] * Tetromino.BLOCK_SIZE, Tetromino.BLOCK_SIZE, Tetromino.BLOCK_SIZE);
            }
        }

        // Check for collisions
        collides(checkFunc) {
            for (let i = 0; i < this.length; i++) {
                const { x, y } = checkFunc(i);
                if (x < 0 || x >= FIELD_WIDTH || y < 0 || y >= FIELD_HEIGHT || FIELD[y][x] !== false) {
                    return true;
                }
            }
            return false;
        }

        // Update the tetromino position
        update(updFunc) {
            for (let i = 0; i < this.length; i++) {
                updFunc(i);
            }
            this.draw();
        }

        // Merge the tetromino into the game field
        merge() {
            for (let i = 0; i < this.length; i++) {
                FIELD[this.y[i]][this.x[i]] = this.color;
            }
        }

        // Rotate the tetromino
        rotate() {
            const maxX = Math.max(...this.x);
            const minX = Math.min(...this.x);
            const minY = Math.min(...this.y);
            const nx = [];
            const ny = [];

            // Calculate new rotated positions
            for (let i = 0; i < this.length; i++) {
                nx.push(maxX + minY - this.y[i]);
                ny.push(this.x[i] - minX + minY);
            }

            // Check for collisions after rotation
            if (!this.collides(i => ({ x: nx[i], y: ny[i] }))) {
                this.clear(); // Clear the current position
                this.x = nx; // Update to new rotated x
                this.y = ny; // Update to new rotated y
                this.draw(); // Draw the rotated tetromino
            }
        }
    }

    // Main game loop
    function draw() {
        if (gameOver) return; // If the game is over, stop drawing and exit the loop.

        // Clear canvas before drawing a new frame
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw the game field (background)
        for (let y = 0; y < FIELD_HEIGHT; y++) {
            for (let x = 0; x < FIELD_WIDTH; x++) {
                if (FIELD[y][x] !== false) {
                    new Tetromino([x], [y], FIELD[y][x]).draw();
                }
            }
        }

        if (tetromino) {
            // Collision check for tetromino
            if (tetromino.collides(i => ({ x: tetromino.x[i], y: tetromino.y[i] + 1 }))) {
                tetromino.merge(); // Merge it into the field
                tetromino = null;  // Prepare for the next tetromino

                // Check for completed rows
                let completedRows = 0;
                for (let y = FIELD_HEIGHT - 1; y >= 0; --y) {
                    if (FIELD[y].every(cell => cell !== false)) {
                        FIELD.splice(y, 1);  // Remove the completed row
                        FIELD.unshift(Array(FIELD_WIDTH).fill(false));  // Add a new empty row at the top
                        completedRows++;  // Count the number of completed rows
                        y++;  // Skip checking the next row since it's shifted down
                    }
                }

                // Update score and lines based on completed rows
                if (completedRows > 0) {
                    score += [10, 100, 300, 1200][completedRows - 1];  // Increment score based on rows cleared
                    lines += completedRows;  // Increment lines cleared

                    // Update the score and lines on the screen
                    scoreLbl.textContent = `Score: ${score}`;
                    linesLbl.textContent = `Lines: ${lines}`;
                }

                // Game over check: If the first row is filled, the game is over
                if (FIELD[0].some(cell => cell !== false)) {
                    alert("Game Over!");
                    endGame();
                }
            } else {
                tetromino.update(i => ++tetromino.y[i]);  // Move the tetromino down
            }
        } else {
            // Create a new tetromino at the top of the field
            const tetrominoes = [
                new Tetromino([0, 0, 0, 0], [0, 1, 2, 3]),
                new Tetromino([0, 0, 1, 1], [0, 1, 0, 1]),
                new Tetromino([0, 1, 1, 1], [0, 0, 1, 2]),
                new Tetromino([0, 0, 0, 1], [0, 1, 2, 0]),
                new Tetromino([0, 1, 1, 2], [0, 0, 1, 1]),
                new Tetromino([0, 1, 1, 2], [1, 1, 0, 1]),
                new Tetromino([0, 1, 1, 2], [1, 1, 0, 0])
            ];

            // Select random tetromino
            tetromino = tetrominoes[Math.floor(Math.random() * tetrominoes.length)];
            tetromino.y = tetromino.y.map(y => y + 2); // Start it a bit lower so it's not on top of the field

            // Game over check: If the top row is already filled, it's game over
            if (tetromino.collides(i => ({ x: tetromino.x[i], y: tetromino.y[i] }))) {
                alert("Game Over!");
                endGame();
                return;
            }

            tetromino.draw();
        }

        setTimeout(draw, delay);  // Continue the game loop
    }

    // Start button event listener
    startButton.addEventListener('click', () => {
        if (!gameStarted) {
            gameStarted = true;
            startGame();
        }
    });

    // Get references to the video and the button
    const video = document.getElementById('gameVideo');

    // Add click event listener to the button
    startButton.addEventListener('click', function() {
    
    // Start the video when the button is clicked
        video.play();
    });

    // Keydown event to move tetrominoes
    window.onkeydown = (event) => {
        if (!tetromino) return;

        switch (event.key) {
            case "ArrowLeft":
                if (!tetromino.collides(i => ({ x: tetromino.x[i] - 1, y: tetromino.y[i] }))) {
                    tetromino.clear(); // Clear previous position
                    tetromino.update(i => --tetromino.x[i]);
                }
                break;
            case "ArrowRight":
                if (!tetromino.collides(i => ({ x: tetromino.x[i] + 1, y: tetromino.y[i] }))) {
                    tetromino.clear(); // Clear previous position
                    tetromino.update(i => ++tetromino.x[i]);
                }
                break;
            case "ArrowDown":
                delay = Tetromino.DELAY / Tetromino.DELAY_INCREASED;
                break;
            case " ":
                tetromino.rotate();
                break;
        }
    };

    // Keyup event to stop the speed-up on ArrowDown key release
    window.onkeyup = (event) => {
        if (event.key === "ArrowDown")
            delay = Tetromino.DELAY;
    };


let delay = 500; // Set initial drop delay (milliseconds)

// Game loop - handles drawing and logic
function draw() {
    if (gameOver) return;

    ctx.clearRect(0, 0, canvas.width, canvas.height);  // Clear canvas

    // Draw the game field
    for (let y = 0; y < FIELD_HEIGHT; y++) {
        for (let x = 0; x < FIELD_WIDTH; x++) {
            if (FIELD[y][x] !== false) {
                ctx.fillStyle = FIELD[y][x];  // Fill color from field
                ctx.fillRect(x * Tetromino.BLOCK_SIZE, y * Tetromino.BLOCK_SIZE, Tetromino.BLOCK_SIZE, Tetromino.BLOCK_SIZE);
            }
        }
    }

    // If there's a tetromino, attempt to drop it
    if (tetromino) {
        if (tetromino.collides(i => ({ x: tetromino.x[i], y: tetromino.y[i] + 1 }))) {
            tetromino.merge();  // Merge tetromino into the field
            tetromino = null;  // Reset tetromino for the next one

            // Check for completed rows
            let completedRows = 0;
            for (let y = FIELD_HEIGHT - 1; y >= 0; --y) {
                if (FIELD[y].every(cell => cell !== false)) {
                    FIELD.splice(y, 1);  // Remove completed row
                    FIELD.unshift(Array(FIELD_WIDTH).fill(false));  // Add new empty row
                    completedRows++;
                    y++;  // Skip next row after shift
                }
            }

            // Update score and lines
            if (completedRows > 0) {
                score += [10, 100, 300, 1200][completedRows - 1];
                lines += completedRows;
                scoreLbl.textContent = `Score: ${score}`;
                linesLbl.textContent = `Lines: ${lines}`;
            }

            // Game over check if the top row is filled
            if (FIELD[0].some(cell => cell !== false)) {
                alert("Game Over!");
                endGame();
                return;
            }
        } else {
            // If no collision, move tetromino down
            tetromino.update(i => tetromino.y[i]++);  // Move down by 1
        }
    } else {
        // Create new tetromino
        spawnTetromino();
    }

    setTimeout(draw, delay);  // Continue the game loop with delay
}

// Function to spawn a new tetromino
function spawnTetromino() {
    const tetrominoes = [
        new Tetromino([0, 0, 0, 0], [0, 1, 2, 3]),
        new Tetromino([0, 0, 1, 1], [0, 1, 0, 1]),
        new Tetromino([0, 1, 1, 1], [0, 0, 1, 2]),
        new Tetromino([0, 0, 0, 1], [0, 1, 2, 0]),
        new Tetromino([0, 1, 1, 2], [0, 0, 1, 1]),
        new Tetromino([0, 1, 1, 2], [1, 1, 0, 1]),
        new Tetromino([0, 1, 1, 2], [1, 1, 0, 0])
    ];

    // Select random tetromino
    tetromino = tetrominoes[Math.floor(Math.random() * tetrominoes.length)];

    // Adjust starting position (slightly below the top of the field)
    tetromino.y = tetromino.y.map(y => y + 2);

    // If the tetromino collides immediately at the top, end the game
    if (tetromino.collides(i => ({ x: tetromino.x[i], y: tetromino.y[i] }))) {
        alert("Game Over!");
        endGame();
        return;
    }

    tetromino.draw();  // Draw the new tetromino
}

// Start the game automatically on page load
window.onload = function() {
    startTimer();
    startGame();  // Automatically start the game when the page loads
    updateGame()
};

// Keydown event to move tetrominoes
window.onkeydown = (event) => {
    if (!tetromino) return;

    switch (event.key) {
        case "ArrowLeft":
            if (!tetromino.collides(i => ({ x: tetromino.x[i] - 1, y: tetromino.y[i] }))) {
                tetromino.clear();
                tetromino.update(i => tetromino.x[i]--);
            }
            break;
        case "ArrowRight":
            if (!tetromino.collides(i => ({ x: tetromino.x[i] + 1, y: tetromino.y[i] }))) {
                tetromino.clear();
                tetromino.update(i => tetromino.x[i]++);
            }
            break;
        case "ArrowDown":
            delay = Tetromino.DELAY / Tetromino.DELAY_INCREASED;  // Speed up drop
            break;
        case " ":
            tetromino.rotate();  // Rotate tetromino
            break;
    }
};

// Keyup event to restore speed after ArrowDown key release
window.onkeyup = (event) => {
    if (event.key === "ArrowDown")
        delay = Tetromino.DELAY;  // Restore original speed
};







    // At the end of the game, redirect to the summary page with the score
function endGame() {
    gameOver = true;
    endMessage.style.display = 'block';
    timerDisplay.style.display = 'none';
    scoreLbl.style.display = 'none';
    linesLbl.style.display = 'none';

    // Redirect to the summary page with the score as a URL query parameter
    //window.location.href = `summary1.html?score=${score}&lines=${lines}`; 

    //setTimeout(function() {
        //window.location.href = `thumbsup1.html?score=${score}&lines=${lines}`;
    //}, 5000);  // 5000 milliseconds = 5 seconds

    // Store score and lines in sessionStorage
    sessionStorage.setItem('score', score);  // Store the score
    sessionStorage.setItem('lines', lines);  // Store the lines cleared
    startCountdown();

    // Optionally, store any other data you need
    // sessionStorage.setItem('otherData', someData);











    // If you want to store rounds data in localStorage, you can use this code:
let roundsData = JSON.parse(localStorage.getItem('roundsData')) || [];
roundsData.push({ round: roundNumber, score: score, lines: lines });
localStorage.setItem('roundsData', JSON.stringify(roundsData));

// After saving, update the round number and store it in sessionStorage for the next round
roundNumber++;
sessionStorage.setItem('roundNumber', roundNumber);

   
}



function startCountdown() {
    const countdownElement = document.getElementById('countdown');  // Get the countdown element

    // Show the countdown div
    countdownElement.style.display = 'block';

    // Update the countdown text initially
    countdownElement.textContent = `Next page will load in: ${countdownValue} seconds`;

    // Set interval to decrease the countdown every second
    countdownInterval = setInterval(() => {
        countdownValue--;  // Decrease the countdown value

        // Update the countdown element with the new value
        countdownElement.textContent = `Next page will load in: ${countdownValue} seconds`;

        // Countdown check
        if (countdownValue <= 0) {
            clearInterval(countdownInterval);  // Stop the countdown

           // if (loopCount > 2) {
                // Increment loopCount
                loopCount++;
            //}

            // Redirect to the next page with the updated loopCount
            window.location.href = `thumbsup.html?loopCount=${loopCount}&score=${score}&lines=${lines}`;
        }
    }, 1000);  // Set interval for 1 second
}





// Check if roundNumber is already in sessionStorage, if not, initialize it
let roundNumber = sessionStorage.getItem('roundNumber');

// If it's the first round, set it to 1, otherwise retrieve the stored roundNumber
if (roundNumber === null) {
    roundNumber = 1;  // First round
} else {
    roundNumber = parseInt(roundNumber);  // For subsequent rounds, parse the value
}
// Store updated rounds data in localStorage
localStorage.setItem('roundsData', JSON.stringify(roundsData));

// Increment round number for the next round and store it in sessionStorage
roundNumber++;
sessionStorage.setItem('roundNumber', roundNumber);


</script>












</body>
</html>
